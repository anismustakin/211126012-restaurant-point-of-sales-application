#labels Phase-Design
#The UML Diagram for the Application

= Introduction =

==This is a UML Illustration for the Online Restaurant Application==


[http://upload.wikimedia.org/wikipedia/commons/thumb/9/99/UML_Diagram_for_a_Online_Restaurant.png/800px-UML_Diagram_for_a_Online_Restaurant.png]





= Details =

The Application will have a Entity Class called *Person*. The *Person* Entity will be composed of three Value Objects: *Name*, *Contact* and *Demographic*. The *Person* Entity will also be associated  with two other entities namely *Logins* and *PersonAddress*. All of these five Classes will have a 1:1 relationship with *Person* as one person(user) can only have one surname, name, address, login details, address and contact details. 

As a person can be either a employee or customer. A Specialization hierarchy with disjointed subtypes were implemented. Thus *Employee* and *Customer* will inherit the attributes and relationships of the *Person* entity. The specialization hierarchy reflects the 1:1 relationship between *Person* and its subtypes *Employee* and *Customer* i.e. a *Employee* subtype occurrence is related to one instance of the *Person* supertype. *Employee* and *Customer* has a disjoint relationship with *Person* which means that each entity instance of the supertype can appear in only one of the subtypes. Which if put simply a Person can either be a *Customer* or a *Employee* but not both. I understand the fact that a employee would also like to be able to order food, and they can do so still when logging in as a employee, but they will still be of type *Employee*. This relationship also has a Total completeness constraint meaning that every supertype occurrence must be a member of at least one subtype. 

The *Employee* also becomes a supertype as a employee can either be a delivery person or a manager with admin rights. The same disjoint relationship and completeness constraints were applied here as with *Person*. Where a *Employee* is either a *DeliveryPerson* or a *ManagerAdmin*, but cannot be both. 

The *Customer* entity class is now be associated with two other Entities. The *Customer* Entity first has a 1:M relationship with *CreditCard* because a customer can have different credit cards he pays with when deciding to make a online payment for the order. 

The *Customer* Entity then has a 1:M relationship with *Orders* as one customer will place multiple orders, but a order will only be associated with one customer thus the navigability goes in both directions. For each order a invoice will be issued and thus *Order* is associated with *CustomerInvoice* in a 1:1 relationship. 

A order will be made up of multiple order items and thus *Orders* has a 1:M aggregated relationship with *OrderItem*, *OrderItem* has a attribute called quantity. Meaning that more than one of a specific order item can be ordered. A order item will be a food product on the menu. Thus *OrderItem* has a 1:1 relationship with *FoodItem*. 

*FoodItem* also has a aggregated 1:M relationship with *FoodCategory* as each food item will belong to a category e.g. Desserts, Beverages, Burgers, Starters etc. 

Our Restaurant also promotes combo meals so that their customers can save money. One combo meal can consist of many food items. Thus the *ComboMeals* Entity has a 1:M relationship with the *FoodItem* entity. How this particularly works is as follows: The combo meal's price will be calculated by adding the selling price of all the different food items it consists of and then deducting a specific amount (discAmount attribute) from the total to give the combo meal price. 

We also have to keep track of the stock as we will not be storing ready made burgers and pizza, but instead the ingredients will be stored separately. Thus one food item e.g. a burger will consist of a bun, patty, lettuce, tomato, chips, sauce etc. which are all separate stock items. Now as a stock item can belong to many food items and a food item can be associated with many stock items. This would cause a M:M relationship, which we would like to avoid. So we create a weak entity. I created a weak entity called *FoodItemContent* which connects with a 1:M Relationship between *FoodItem* and *StockItems*. 

==Additional Questions that I still need to answer in regards to my diagram==
 * relationship between ComboMeals and FoodItem?